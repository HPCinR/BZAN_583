---
title: "HPC Software"
format: 
  revealjs:
    slide-number: c/t
    width: 1200
    height: 800
    chalkboard: true
    code-link: true
    code-line-numbers: false
editor: source
engine: knitr
---

## Two (Three) Basic Concepts in Hardware {background-image="/pics/ParallelSoftware/ParallelSoftware1.png" background-size="80%" background-position="center"}

## (Two) Three Basic Concepts from Software Viewpoint {background-image="/pics/ParallelSoftware/ParallelSoftware2.png" background-size="80%" background-position="center"}

## Native Programming Mindset {background-image="/pics/ParallelSoftware/ParallelSoftware3.png" background-size="80%" background-position="center"}

## Native Programming Models and Tools {background-image="/pics/ParallelSoftware/ParallelSoftware4.png" background-size="80%" background-position="center"}

## 40 Years of Parallel Computing {background-image="/pics/ParallelSoftware/ParallelSoftware5.png" background-size="80%" background-position="center"}

## Last 20 years of Advances {background-image="/pics/ParallelSoftware/ParallelSoftware6.png" background-size="80%" background-position="center"}

## Distributed Programming Works in Shared Memory {background-image="/pics/ParallelSoftware/ParallelSoftware7.png" background-size="80%" background-position="center"}

## R Interfaces to Low-Level Native Tools {background-image="/pics/ParallelSoftware/ParallelSoftware8.png" background-size="80%" background-position="center"}

## `parallel::mclapply()` {background-image="/pics/ParallelSoftware/ParallelSoftware9.png" background-size="80%" background-position="center"}


## Unix `fork`   {.smaller}

#### Operating system forks a new process with pointers to same memory: A memory-efficient parallelism on shared memory devices running Unix-like OS   
* **Copy-on-write:** memory copied only if modified 
* **parallel** package `mclapply()` and friends  
* Use for numerical sections only  
  * Avoid GUI, I/O, and graphics sections (common device handles)  
* Convenient for data (read, not modified)  
* Convenient for functional languages like R  
* Avoid or manage nested parallelism  
  * OpenBLAS takes all cores by default  
  * **data.table** automatically switches to single threaded mode upon fork  
<br>

A deeper discussion of `fork` memory (if you have interest) on [YouTube](https://www.youtube.com/watch?v=8hVLcyBkSXY) by Chris Kanich (UIC)

## Copy-on-write  {background-image="/pics/fork/Slide1.png" background-size="90%" background-position="center"}

::: notes
* All done with pointers
* Memory is in pages
* Processes not aware of each other or other's memory use
* OS is aware of memory use
* 16 forks write = 16 copies of memory
:::

## Mapping Threads to Cores {background-image="/pics/fork/iDVTstR.jpg" background-size="30%" background-position="center right" .smaller}  
### Theory and Reality  

* Operating system manages core affinity  

* Operating system tasks can compete  

* Core switching occurs frequently  

* **But it works rather well!**  

## Code first with `lapply()`, then switch to `mclapply()` {.smaller}

Drop-in replacements (almost) for `lapply()`, `mapply()`, and `Map()`

```{r}
#| echo: true
#| eval: false
mclapply(X, FUN, ...,
         mc.preschedule = TRUE, mc.set.seed = TRUE,
         mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),
         mc.cleanup = TRUE, mc.allow.recursive = TRUE, affinity.list = NULL)

mcmapply(FUN, ...,
         MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE,
         mc.preschedule = TRUE, mc.set.seed = TRUE,
         mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),
         mc.cleanup = TRUE, affinity.list = NULL) 

mcMap(f, ...)
```

Debugging easier with `lapply()`